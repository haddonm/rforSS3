

#' @title getprojdyn tabulates the projected catches from a set of scenarios
#' 
#' @description getprojdyn is used to tabulate the projected catches, spawning
#'     biomass depletion, spawning biomass, and estimated parameters from a
#'     set of different scenarios within SS3. It requires the use of the 
#'     function getreplists to aggregate the outputs from the different 
#'     scenarios.
#'
#' @param compscenes the output from getreplist
#' 
#' @seealso{
#'    \link{getreplists}
#' } 
#'
#' @returns a list of projcatch, projdepl, projspawn, and parmscen - the 
#'     estimated parameters from each scenario
#' @export
#'
#' @examples
#' # compscenes <- getreplists(store=store,
#' #                           scenes=c("BC-5-5-1","BC-5-35-1","BC-5-5-75"),
#' #                           listname="plotreport")
#' # outproj <- getprojdyn(compscenes)
getprojdyn <- function(compscenes) {
  catches <- compscenes$catches
  scenes <- names(catches)
  nscen <- length(scenes)
  scen1catch <- catches[[1]]
  pickproj <- which(scen1catch$Era == "FORE")
  pick1 <- pickproj[1]
  projpick <- c((pick1-5):(pick1-1), pickproj)
  numrow <- length(projpick)
  yrs <- scen1catch[projpick,"year"]
  columns <- c("year",scenes)
  total <- compscenes$total
  parm <- total[[1]]$parameters
  pickparm <- which(parm[,"Phase"] > 0)
  nparm <- length(pickparm)
  parmscen <- matrix(0,nrow=nparm,ncol=nscen,
                     dimnames=list(parm[pickparm,"Label"],scenes))
  projcatch <- as.data.frame(matrix(nrow=numrow,ncol=length(columns),
                                    dimnames=list(yrs,columns)))
  projcatch[,1] <- yrs
  projdepl <- projspawn <- projcatch
  for (i in 1:nscen) {
    projcatch[,i+1] <- catches[[i]]$TotalC[projpick]
    projdepl[,i+1] <- catches[[i]]$Depletion[projpick]
    projspawn[,i+1] <- catches[[i]]$SpawnB[projpick]
    parmscen[,i] <- total[[i]]$parameters[pickparm,"Value"]
  }
  return(list(projcatch=projcatch,projdepl=projdepl,projspawn=projspawn,
              parmscen=parmscen))
} # getprojdyn

#' @title getreplists loads a set of SS_output outputs into a set of lists
#' 
#' @description getreplists allows comparisons between alternative scenarios run
#'     in Stock synthesis 3 by loading the different replist objects generated
#'     by the r4ss function SS_output. Each of the different scenarios is saved
#'     into a list, as well as extracting the timeseries from each, and the 
#'     catches. Two approaches to identifying the paths leading to the various
#'     scenarios are implemented. The first uses the method implemented when
#'     using rforSS3 that has a 'store' which is the directory containing 
#'     separate sub-directories for each scenario being considered and it 
#'     generates the filenames to be generated from the various identified
#'     scenes or scenarios. The alternative is to provide a character vector
#'     containing the full paths and filenames of the SS_output objects to be
#'     compared.
#'
#' @param store is a directory that contains separate sub-directories for each
#'     scenario, each of which contains an object generated by SS_output. If 
#'     the paths option is used instead then store can be set to NA or NULL.
#' @param listname The standard name for the object output from SS_output, if
#'     the paths option is used instead then store can be set to NA or NULL.
#' @param scenes a character vector of the names given to each scenario, this
#'     is required by both approaches for file loading as these names will be
#'     used to label each scenario.
#' @param paths default = NULL, meaning the rforSS3 approach will be used, which
#'     requires only the scenes argument to contain information.
#'      
#' @seealso{
#'   \link[r4ss]{SS_output}, \link{projectedcatches}, \link{projreceffects}
#' }
#' 
#' @returns a list of lists so for each scenario a list of the timeseries, of
#'     the catches, and of the SS_output object in their entirety.
#' @export
#'
#' @examples
#' # require(r4ss)
#' # require(codeutils)
#' # compscenes <- getreplists(store="c:/afishsps/",listname="plotreport",
#' #             scenes=c("basecase_1","basecase_Rp7"),paths=NULL)
#' # alternatively
#' # compscenes <- getreplists(store=NULL,listname=NULL,
#' #                           scenes=c("basecase_1","basecase_Rp7"),
#' #             paths=c("c:/afishsps/basecase_1/plotreport_basecase_1.Rdata",
#' #                     "c:/afishsps/basecase_1/plotreport_basecase_Rp7.Rdata")
getreplists <- function(store,listname,scenes,paths=NULL) {
  nscen <- length(scenes)
  if (nscen < 2) stop("More than 1 scenario needed in getreplists \n")
  total <- makelist(scenes)
  dyn <- makelist(scenes)
  catches <- makelist(scenes)
  for (i in 1:nscen) {  # i = 1
    
    if (is.null(paths)) {
      filen <- paste0(listname,"_",scenes[i],".Rdata")      
      pickdir <- pathtopath(store,scenes[i])
      filename <- pathtopath(pickdir,filen)
    } else {
      filename <- paths[i]
    }
    load(filename)
    total[[i]] <- get(listname)
    timeseries <- total[[i]]$timeseries
    dyn[[i]] <- timeseries
    catches[[i]] <- projectedcatches(total[[i]])
  }
  return(list(timeseries=dyn,catches=catches,total=total))
} # end of getreplists

#' @title projectedcatches allows alternative SS3 model catches to be compared
#' 
#' @description projectedcatches After fitting an optimal stock assessment
#'     model using SS3 it is usual to generate the predicted catches needed to
#'     move a fishery towards a given harvest strategy policy target reference 
#'     point. To do this it used to be standard practice to use recruitment 
#'     levels taken from the predicted stock recruitment relationship. However,
#'     it has become a good practice to consider the recent history of 
#'     predicted recruitment and modify the projected recruitment levels taken
#'     of the stock recruitment relationship such that they are similar to the 
#'     last 5 to 10 years. SS3 has an option in the forecast file called either
#'     # multiplier on base recruitment or # scalar/multiplier or value applied 
#'     to SR-curve. If such a modification is made it would be usual practice 
#'     to compare the predicted catches with and with the adjustment. This
#'     function extracts the total catches 
#'
#' @param plotreport the output from SS_outout, a replist
#' 
#' @seealso{
#'   \link[r4ss]{SS_output}, \link{getreplists}, \link{projreceffects}
#' }
#'
#' @returns A matrix of the catches including the projections, of spawnB, 
#'     recruits, and depletion
#' @export
#'
#' @examples
#' # catches <- projectedcatches(plotreport=paste0(destination,"filename.Rdata"))
projectedcatches <- function(plotreport) {
  fleets <- plotreport$FleetNames
  nfleet <- length(fleets)
  namecols <- c("year","SpawnB","recruits",paste0("C(B)_",fleets),"TotalC",
                "Depletion","ABC-Buffer","Era")
  columns <- c(2,7,8,17,25,33,41,49)
  catches <- plotreport$timeseries[,columns]
  depl=catches[,2]/catches[1,2]
  abc <-  plotreport$timeseries[,"ABC_buffer"]
  era <-  plotreport$timeseries[,"Era"]
  catchall <- cbind(catches,rowSums(catches[,4:8]),depl,abc,era)
  colnames(catchall) <- namecols
  return(catchall)
} # end of projectedcatches

#' @title plotreceffects compares SpawnB, Catches, Recruits and depletion
#' 
#' @description plotreceffects generates a combined plot of SpawnB, Catches, 
#'     Recruits, and spawning biomass depletion for all scenarios being 
#'     compared. This assumes all scenarios have similar properties such as 
#'     having teh same endyr.
#'
#' @param compscenes the output from getreplists, this is a list of three lists
#'     the timeseries from each scenario's SS_output replist, the catches from
#'     each scenario, and the total replist objects from each scenario for
#'     further analyses. 
#' @param rundir the full path to the directory into which the output plot 
#'     should be saved if console = FALSE. The default = ""
#' @param legcex default=1.25 but if there are many scenarios it should be less
#' @param console default = TRUE, meaning the plot will be sent to the console
#' 
#' @seealso{
#'   \link[r4ss]{SS_output}, \link{projectedcatches}, \link{getreplists}
#' }
#'
#' @returns an invisible list of SpawnB, Total Catches, recruits, spawning
#'     biomass depletion, standardized Instantenous F, and F from biggest Fleet 
#' @export
#'
#' @examples
#' # require(hplot)
#' # require(codeutils)
#' # compscenes getreplists(store="c:/afishsps/",listname="plotreport",
#' #             scenes=c("basecase_1","basecase_Rp7"),paths=NULL)
#' # projout <- projreceffects(compscenes,rundir="",console=TRUE)
#' # str(projout)
projreceffects <- function(compscenes,rundir="",legcex=1.25,console=TRUE) {
  catches <- compscenes$catches
  scenes <- names(catches)
  nscen <- length(catches)
  numrow <- nrow(catches[[1]])
  pickyrs <- 2:numrow  # omit the first row
  allyrs <- catches[[1]]$year
  yrs <- allyrs[pickyrs]
  nyrs <- length(yrs)
  endyr <- compscenes$total[[1]]$endyr
  oldpar <- par(no.readonly=TRUE)
  on.exit(par(oldpar))
  filen <- ""
  if (!console) {
    nfile <- "SS3_scenario_comparison.png"
    filen <- pathtopath(rundir,nfile)
  }
  plotprep(width=10,height=9,newdev=TRUE,filename=filen,cex=1.0,verbose=FALSE)
  parset(plots=c(3,2),cex=1.0,margin=c(0.3,0.45,0.1,0.1),
         outmargin=c(1,0,0,0))
  spawnB <- sapply(catches,"[[","SpawnB")
  rownames(spawnB) <- allyrs
  maxy <- getmax(spawnB[pickyrs])
  plot(yrs,spawnB[pickyrs,1],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab="Spawning Biomass",xlab="",panel.first=grid())
  #points(yrs[1],spawnB[1,1])
  for (i in 2:nscen) lines(yrs,spawnB[pickyrs,i],lwd=2,col=i)
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  totalC <- sapply(catches,"[[","TotalC")
  rownames(totalC) <- allyrs
  maxy <- getmax(totalC[pickyrs])
  plot(yrs,totalC[pickyrs,1],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab="Catch (t)",xlab="",panel.first=grid())
  for (i in 2:nscen) lines(yrs,totalC[pickyrs,i],lwd=2,col=i)
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  legend("bottomleft",legend=scenes,lwd=3,col=1:nscen,cex=legcex,bty="n") 
  recruits <- sapply(catches,"[[","recruits")
  rownames(recruits) <- allyrs
  projvals <- tail(recruits,1)
  maxy <- getmax(recruits[pickyrs])
  plot(yrs,recruits[pickyrs,1],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab="Recruits",xlab="",panel.first=grid())
  lines(yrs,rep(projvals[1],nyrs),lwd=1,lty=2,col=1)
  for (i in 2:nscen) {
    lines(yrs,recruits[pickyrs,i],lwd=2,col=i)
    lines(yrs,rep(projvals[i],nyrs),lwd=1,lty=2,col=i)
  }
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  depl <- sapply(catches,"[[","Depletion")
  rownames(depl) <- allyrs
  maxy <- getmax(depl[pickyrs])
  plot(yrs,depl[pickyrs,1],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab="Spawning Biomass Depletion",xlab="",panel.first=grid())
  for (i in 2:nscen) lines(yrs,depl[pickyrs,i],lwd=2,col=i)
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  # plot instantaneous F rates
  total <- compscenes$total
  scenes <- names(total)
  nscen <- length(scenes)
  instF <- makelist((scenes))
  nfleet <- total[[1]]$nfleets
  for ( i in 1:nscen) instF[[i]] <- total[[i]]$exploitation[,c(1,4:(6+nfleet))]
  first <- instF[[1]]
  yrs <- first[,"Yr"]
  maxy <- getmax(sapply(instF,"[[","F_std"))
  plot(yrs,first[,"F_std"],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab="Overall Instantaneous F",xlab="",panel.first=grid())
  for (i in 2:nscen) lines(yrs,instF[[i]][,"F_std"],lwd=3,col=i)
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  legend("bottomleft",legend=scenes,lwd=3,col=1:nscen,cex=legcex,bty="n") 
  # Plot individual fleet with maximum F
  numcol <- ncol(first)
  flnames <- colnames(first)
  fleetF <- apply(first,2,max,na.rm=TRUE)[5:numcol]
  pickFl <- which.max(fleetF) + 4
  Flmax <- flnames[pickFl]
  maxFL <- sapply(instF,"[[",Flmax)
  rownames(maxFL) <- yrs
  maxy <- getmax(maxFL)
  plot(yrs,maxFL[,1],type="l",lwd=2,col=1,ylim=c(0,maxy),yaxs="i",
       ylab=paste0("Fleet with Maximum F: ",Flmax),xlab="",panel.first=grid())
  for (i in 2:nscen) lines(yrs,maxFL[,i],lwd=2,col=i)
  abline(v=(endyr + 0.5),lwd=1,col=1,lty=3)
  mtext("Year",side=1,outer=TRUE,cex=1.2,line=-0.2)
  if (!console) dev.off()
  return(invisible(list(spawnB=spawnB,totalC=totalC,recruits=recruits,
                        depl=depl,instF=instF,maxFL=maxFL)))
} # end of projreceffects
