

#' @title getprojdyn tabulates the projected catches from a set of scenarios
#' 
#' @description getprojdyn is used to tabulate the projected catches, spawning
#'     biomass depletion, spawning biomass, and estimated parameters from a
#'     set of different scenarios within SS3. It requires the use of the 
#'     function getreplists to aggregate the outputs from the different 
#'     scenarios.
#'
#' @param compscenes the output from getreplist
#' 
#' @seealso{
#'    \link{getreplists}
#' } 
#'
#' @returns a list of projcatch, projdepl, projspawn, and parmscen - the 
#'     estimated parameters from each scenario
#' @export
#'
#' @examples
#' # compscenes <- getreplists(store=store,
#' #                           scenes=c("BC-5-5-1","BC-5-35-1","BC-5-5-75"),
#' #                           listname="plotreport")
#' # outproj <- getprojdyn(compscenes)
getprojdyn <- function(compscenes) {
  catches <- compscenes$catches
  scenes <- names(catches)
  nscen <- length(scenes)
  scen1catch <- catches[[1]]
  pickproj <- which(scen1catch$Era == "FORE")
  pick1 <- pickproj[1]
  projpick <- c((pick1-5):(pick1-1), pickproj)
  numrow <- length(projpick)
  yrs <- scen1catch[projpick,"year"]
  columns <- c("year",scenes)
  total <- compscenes$total
  parm <- total[[1]]$parameters
  pickparm <- which(parm[,"Phase"] > 0)
  nparm <- length(pickparm)
  parmscen <- matrix(0,nrow=nparm,ncol=nscen,
                     dimnames=list(parm[pickparm,"Label"],scenes))
  projcatch <- as.data.frame(matrix(nrow=numrow,ncol=length(columns),
                                    dimnames=list(yrs,columns)))
  projcatch[,1] <- yrs
  projdepl <- projspawn <- projcatch
  for (i in 1:nscen) {
    projcatch[,i+1] <- catches[[i]]$TotalC[projpick]
    projdepl[,i+1] <- catches[[i]]$Depletion[projpick]
    projspawn[,i+1] <- catches[[i]]$SpawnB[projpick]
    parmscen[,i] <- total[[i]]$parameters[pickparm,"Value"]
  }
  return(list(projcatch=projcatch,projdepl=projdepl,projspawn=projspawn,
              parmscen=parmscen))
} # getprojdyn

#' @title getreplists loads a set of SS_output outputs into a set of lists
#' 
#' @description getreplists allows comparisons between alternative scenarios run
#'     in Stock synthesis 3 by loading the different replist objects generated
#'     by the r4ss function SS_output. Each of the different scenarios is saved
#'     into a list, as well as extracting the timeseries from each, and the 
#'     catches. Two approaches to identifying the paths leading to the various
#'     scenarios are implemented. The first uses the method implemented when
#'     using rforSS3 that has a 'store' which is the directory containing 
#'     separate sub-directories for each scenario being considered and it 
#'     generates the filenames to be generated from the various identified
#'     scenes or scenarios. The alternative is to provide a character vector
#'     containing the full paths and filenames of the SS_output objects to be
#'     compared.
#'
#' @param store is a directory that contains separate sub-directories for each
#'     scenario, each of which contains an object generated by SS_output. If 
#'     the paths option is used instead then store can be set to NA or NULL.
#' @param listname The standard name for the object output from SS_output, if
#'     the paths option is used instead then store can be set to NA or NULL.
#' @param scenes a character vector of the names given to each scenario, this
#'     is required by both approaches for file loading as these names will be
#'     used to label each scenario.
#' @param paths default = NULL, meaning the rforSS3 approach will be used, which
#'     requires only the scenes argument to contain information. Otherwise, 
#'     scenes can be NULL and paths should contain a character vector made up 
#'     of the complete path and filename for each Rdata file stored wherever 
#'     they are stored.
#'      
#' @seealso{
#'   \link[r4ss]{SS_output}, \link{projectedcatches}
#' }
#' 
#' @returns a list of lists so for each scenario a list of the timeseries, of
#'     the catches, of the SS_output object in their entirety and the output
#'     from summarizeSS3.
#' @export
#'
#' @examples
#' # require(r4ss)
#' # require(codeutils)
#' # compscenes <- getreplists(store="c:/afishsps/",listname="plotreport",
#' #             scenes=c("basecase_1","basecase_Rp7"),paths=NULL)
#' # alternatively
#' # compscenes <- getreplists(store=NULL,listname=NULL,
#' #                           scenes=c("basecase_1","basecase_Rp7"),
#' #             paths=c("c:/afishsps/basecase_1/plotreport_basecase_1.Rdata",
#' #                     "c:/afishsps/basecase_1/plotreport_basecase_Rp7.Rdata")
getreplists <- function(store,listname,scenes,paths=NULL) {
  nscen <- length(scenes)
  if (nscen == 1) warning("Only 1 scenario in getreplists \n")
  total <- makelist(scenes)
  dyn <- makelist(scenes)
  catches <- makelist(scenes)
  scenesum <- makelist(scenes)
  for (i in 1:nscen) {  # i = 1
    if (is.null(paths)) {
      filen <- paste0(listname,"_",scenes[i],".Rdata")      
      pickdir <- pathtopath(store,scenes[i])
      filename <- pathtopath(pickdir,filen)
    } else {
      filename <- paths[i]
    }
    load(filename)
    total[[i]] <- get(listname)
    scenesum[[i]] <- summarizeSS3(total[[i]])
    timeseries <- total[[i]]$timeseries
    dyn[[i]] <- timeseries
    catches[[i]] <- projectedcatches(total[[i]])
  }
  return(list(timeseries=dyn,catches=catches,total=total,scenesum=scenesum,
              scenes=scenes))
} # end of getreplists

#' @title projectedcatches allows alternative SS3 model catches to be compared
#' 
#' @description projectedcatches After fitting an optimal stock assessment
#'     model using SS3 it is usual to generate the predicted catches needed to
#'     move a fishery towards a given harvest strategy policy target reference 
#'     point. To do this it used to be standard practice to use recruitment 
#'     levels taken from the predicted stock recruitment relationship. However,
#'     it has become a good practice to consider the recent history of 
#'     predicted recruitment and modify the projected recruitment levels taken
#'     of the stock recruitment relationship such that they are similar to the 
#'     last 5 to 10 years. SS3 has an option in the forecast file called either
#'     # multiplier on base recruitment or # scalar/multiplier or value applied 
#'     to SR-curve. If such a modification is made it would be usual practice 
#'     to compare the predicted catches with and with the adjustment. This
#'     function extracts the total catches 
#'
#' @param plotreport the output from SS_outout, a replist
#' 
#' @seealso{
#'   \link[r4ss]{SS_output}, \link{getreplists}
#' }
#'
#' @returns A matrix of the catches including the projections, of spawnB, 
#'     recruits, depletion, total catches and ERA
#' @export
#'
#' @examples
#' # catches <- projectedcatches(plotreport=paste0(destination,"filename.Rdata"))
projectedcatches <- function(plotreport) {
  fleets <- plotreport$FleetNames
  timeseries <- plotreport$timeseries
  deadB <- grep("dead(B)",names(timeseries),fixed=TRUE)
  findfleets <-which(plotreport$fleet_type == 1)
  namecols <- c("year","SpawnB","recruits",
                paste0("C(B)_",fleets[findfleets]),"TotalC",
                "Depletion","ABC-Buffer","Era")
  columns <- c(2,7,8,deadB)
  ncatch <- length(deadB)
  catches <- timeseries[,columns]
  depl=catches[,2]/catches[1,2]
  abc <-  timeseries[,"ABC_buffer"]
  era <-  timeseries[,"Era"]
  catchall <- cbind(catches,rowSums(catches[,4:(ncatch+3)]),depl,abc,era)
  colnames(catchall) <- namecols
  return(catchall)
} # end of projectedcatches

